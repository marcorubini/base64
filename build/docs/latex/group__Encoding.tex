\hypertarget{group__Encoding}{}\doxysection{Encoding}
\label{group__Encoding}\index{Encoding@{Encoding}}


Function objects that encode ranges of bytes.  


\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr auto \mbox{\hyperlink{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba}{ml\+::base64\+::encode\+\_\+bytes}}
\begin{DoxyCompactList}\small\item\em Encode a range of bytes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__Encoding_ga55f46a1613b8d5a2e3dcca5d76d0f4fc}\label{group__Encoding_ga55f46a1613b8d5a2e3dcca5d76d0f4fc}} 
constexpr auto {\bfseries ml\+::base64\+::encode\+\_\+bytes\+\_\+n}
\begin{DoxyCompactList}\small\item\em Like \mbox{\hyperlink{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba}{encode\+\_\+bytes}} but invocable with a start iterator and a size. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Function objects that encode ranges of bytes. 

Encoding function objects accept a range of byte-\/like types. A byte-\/like type is a trivial type of size 1.

You can optionally pass a projection that converts the range value type to std\+::byte. The default projection uses std\+::bit\+\_\+cast.

Multiple overloads are available, you can use pairs of iterators or input ranges.

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000001}{Todo}}]Allow configuring the encoding algorithm.\end{DoxyRefDesc}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba}\label{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba}} 
\index{Encoding@{Encoding}!encode\_bytes@{encode\_bytes}}
\index{encode\_bytes@{encode\_bytes}!Encoding@{Encoding}}
\doxysubsubsection{\texorpdfstring{encode\_bytes}{encode\_bytes}}
{\footnotesize\ttfamily ml\+::base64\+::encode\+\_\+bytes\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



Encode a range of bytes. 

\begin{DoxyRemark}{Remarks}
The input range does not have string semantics, it is not expected to be null terminated. Any null terminator will be encoded. This is a problem if you try to encode character arrays with string semantics, like\+: \begin{DoxyVerb}ml::base64::encode("Man", output);
\end{DoxyVerb}
 To fix this, use std\+::string\+\_\+view instead of character arrays.

Likewise, the output is not null terminated. When the output is a character array with string semantics, you need to manually add the null terminator.
\end{DoxyRemark}
\hypertarget{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md1}{}\doxysubsubsection{Example -\/ Encoding a string}\label{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md1}
\begin{DoxyVerb}std::string_view text = "ABC";
std::string result;
ml::base64::encode_bytes(text, back_inserter(result));
\end{DoxyVerb}
 \hypertarget{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md2}{}\doxysubsubsection{Example -\/ Iterator interface}\label{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md2}
\begin{DoxyVerb}std::string_view text = "ABC";
std::string result;
ml::base64::encode_bytes(text.begin(), text.end(), back_inserter(result));
\end{DoxyVerb}
 \hypertarget{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md3}{}\doxysubsubsection{Example -\/ Encoding a stream}\label{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md3}
\begin{DoxyVerb}auto in = std::ranges::istream_view<char>(std::cin);
std::string result;
ml::base64::encode_bytes(in, back_inserter(result));
\end{DoxyVerb}
 \hypertarget{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md4}{}\doxysubsubsection{Example -\/ Adding null terminator}\label{group__Encoding_gae0b0ee4f7585e5e7b7f6c5e5dfedf6ba_autotoc_md4}
\begin{DoxyVerb}std::string_view text = "ABC";
char result[100];
char* last = ml::base64::encode_bytes(text, result);
*last = '\0';
\end{DoxyVerb}
 